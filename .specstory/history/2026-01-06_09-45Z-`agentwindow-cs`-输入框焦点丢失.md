<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 672cba37-94d3-4816-b4e7-b8d6d8f4e1cf (2026-01-06 09:45Z) -->

# `AgentWindow.cs` 输入框焦点丢失 (2026-01-06 09:45Z)

_**User (2026-01-06 06:59Z)**_

@AgentWindow.cs 在每次输出结束后，input box会失去focus。这不行

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
用户反馈在每次输出结束后，input box 会失去 focus。这是一个 UX 问题，需要在输出结束后自动将焦点重新设置到输入框。

让我看看代码中的输入框是如何绘制的：

```csharp
void DrawInputField()
{
    var evt = Event.current;
    
    // Handle Enter to send, Shift+Enter for newline
    if (evt.type == EventType.KeyDown && evt.keyCode == KeyCode.Return)
    {
        if (!evt.shift && !isRunning && !string.IsNullOrWhiteSpace(inputText))
        {
            // Enter without shift - send message
            evt.Use();
            SendRequestAsync().Forget();
            return;
        }
        // Shift+Enter - let it insert newline naturally
    }
    
    inputScroll = EditorGUILayout.BeginScrollView(inputScroll, GUILayout.Height(80));
    inputText = EditorGUILayout.TextArea(
        inputText,
        wordWrapTextAreaStyle,
        GUILayout.ExpandHeight(true),
        GUILayout.ExpandWidth(true));
    EditorGUILayout.EndScrollView();
}
```

问题是当 `isRunning` 从 `true` 变为 `false` 时（即输出结束后），焦点会丢失。

在 Unity Editor GUI 中，要控制焦点，我们需要使用 `GUI.FocusControl` 或 `EditorGUI.FocusTextInControl`。首先需要给控件一个名字（通过 `GUI.SetNextControlName`），然后在适当的时候调用焦点函数。


解决方案是给 TextArea 设置一个控件名称，并在 `isRunning` 从 `true` 变为 `false` 时自动聚焦到输入框。我需要添加一个字段来跟踪是否需要聚焦，然后在 `isRunning` 变为 false 的地方设置这个标志。

在绘制输入字段时，我定义一个常量作为控件的标识符。处理 Enter 键的逻辑：当按下 Enter 且没有按 Shift、程序未运行且输入不为空时，就发送消息；如果是 Shift+Enter 则允许换行。当需要聚焦且处于重绘事件时，清除聚焦标志并将焦点设置到指定的控件上。

然后创建一个滚动视图来容纳文本输入区域，设置控件名称后使用 TextArea 显示可编辑的多行文本。最后需要在 `isRunning` 变为 false 的地方设置 `shouldFocusInput = true`，这样用户在请求完成后能立即继续输入。在 `SendRequestAsync` 的 finally 块以及其他设置 `isRunning = false` 的位置都应该添加这个标志。</details></think>

---

我来分析这个问题。在输出结束后，`isRunning` 变为 `false`，但输入框没有自动获得焦点。我需要添加自动聚焦的逻辑。

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: com.nuskey.unity-agent-client/Editor/AgentWindow.cs</summary>

**Chunk 1**
Lines added: 4, lines removed: undefined

```diff
@@ -87,4 +87,8 @@
          TaskCompletionSource&lt;JToken&gt; pendingInputTcs;
          string pendingInputText;
+ 
+         // Input focus management
+         const string InputControlName = "AgentInputField";
+         bool shouldFocusInput;
  
          [MenuItem("Tools/Unity ACP Client")]
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I need to modify the DrawInputField method to set the control name and handle focusing.</details></think>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: com.nuskey.unity-agent-client/Editor/AgentWindow.cs</summary>

**Chunk 1**
Lines added: 8, lines removed: undefined

```diff
@@ -746,6 +746,14 @@
                  // Shift+Enter - let it insert newline naturally
              }
+             
+             // Auto-focus input field after agent finishes responding
+             if (shouldFocusInput &amp;&amp; evt.type == EventType.Repaint)
+             {
+                 shouldFocusInput = false;
+                 EditorGUI.FocusTextInControl(InputControlName);
+             }
              
              inputScroll = EditorGUILayout.BeginScrollView(inputScroll, GUILayout.Height(80));
+             GUI.SetNextControlName(InputControlName);
              inputText = EditorGUILayout.TextArea(
                  inputText,
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Now I need to modify the places where `isRunning` is set to `false` to also set `shouldFocusInput = true`. The main place is in `SendRequestAsync`'s finally block.</details></think>

---

现在修改 `SendRequestAsync` 的 finally 块，在 `isRunning` 变为 `false` 时触发聚焦：

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: com.nuskey.unity-agent-client/Editor/AgentWindow.cs</summary>

**Chunk 1**
Lines added: 5, lines removed: 1

```diff
@@ -1288,5 +1288,9 @@
              finally
              {
-                 EnqueueUi(() =&gt; isRunning = false);
+                 EnqueueUi(() =&gt;
+                 {
+                     isRunning = false;
+                     shouldFocusInput = true;
+                 });
              }
          }
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
I should also set focus after cancel session. Let me update that too.</details></think>

---

同样修改 `CancelSessionAsync` 的 finally 块：

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: com.nuskey.unity-agent-client/Editor/AgentWindow.cs</summary>

**Chunk 1**
Lines added: 5, lines removed: 1

```diff
@@ -1372,5 +1372,9 @@
              finally
              {
-                 EnqueueUi(() =&gt; isRunning = false);
+                 EnqueueUi(() =&gt;
+                 {
+                     isRunning = false;
+                     shouldFocusInput = true;
+                 });
              }
          }
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
Let me check for linter errors now.</details></think>

---

现在检查有没有编译错误：

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_unityMCP_unity_editor">
<details>
          <summary>Tool use: **mcp_unityMCP_unity_editor**</summary>
      
*Called tool*: unityMCP - unity_editor: Controls Unity Editor state (play/pause/stop), retrieves project information and full UnityCurrentState, manages editor tools, windows, selection, tags, and layers. Use get_current_state for comprehensive state snapshot.

*Parameters*:
  * action: get_current_state

*Result*:
{
  "success": true,
  "message": "Command executed successfully",
  "data": {
    "success": true,
    "message": "Retrieved full Unity state snapshot.",
    "state": {
      "editor": {
        "playMode": "stopped",
        "focusedWindow": "AgentWindow",
        "requiresFocusForOperations": false,
        "isCompiling": false,
        "isUpdating": false,
        "lastCompilation": {
          "status": "idle"
        },
        "timeSinceStartup": 3713.41748
      },
      "project": {
        "srp": "builtin",
        "defineSymbols": [
          "ODIN_INSPECTOR_EDITOR_ONLY",
          "ODIN_INSPECTOR",
          "ODIN_INSPECTOR_3",
          "RPK_WEIXIN",
          "GRAVITY_WECHAT_GAME_MODE",
          "RPK_UOS_LOGIN",
          "RPK_UOS_PUSH",
          "RPK_WXIAA_PLUGIN"
        ],
        "packages": [],
        "dirty": false
      },
      "scene": {
        "activeScenePath": "Assets/B_Scenes/Game_3.unity",
        "dirty": false,
        "hasNavMeshData": false,
        "hasLightingData": true
      },
      "selection": {
        "activeObject": null
      },
      "console": {
        "sinceToken": null,
        "unreadCount": 0,
        "lastErrors": []
      },
      "assets": {
        "touched": []
      },
      "operations": {
        "pending": []
      },
      "policy": {
        "writeGuardInPlayMode": "deny",
        "refreshMode": "debounced",
        "consoleReadPolicy": "must_clear_before_read"
      },
      "rev": 1
    }
  }
}
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, the editor is not compiling. Let me trigger a compilation to check if there are any errors.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_unityMCP_unity_console">
<details>
          <summary>Tool use: **mcp_unityMCP_unity_console**</summary>
      
*Called tool*: unityMCP - unity_console: Gets messages from or clears the Unity Editor console. Supports filtering by message type, text content, timestamp, and formatting options. Clear action returns a sinceToken for subsequent incremental reads.

*Parameters*:
  * action: clear

*Result*:
{
  "success": true,
  "message": "Command executed successfully",
  "data": {
    "success": true,
    "message": "Console cleared successfully.",
    "data": {
      "sinceToken": "639032895986938351-9",
      "scope": "all"
    },
    "state_delta": {
      "console": {
        "sinceToken": "639032895986938351-9",
        "unreadCount": 0,
        "lastErrors": []
      }
    }
  }
}
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, console is now cleared. Let me trigger a compilation.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_unityMCP_unity_editor">
<details>
          <summary>Tool use: **mcp_unityMCP_unity_editor**</summary>
      
*Called tool*: unityMCP - unity_editor: Controls Unity Editor state (play/pause/stop), retrieves project information and full UnityCurrentState, manages editor tools, windows, selection, tags, and layers. Use get_current_state for comprehensive state snapshot.

*Parameters*:
  * action: request_compile

*Result*:
{
  "success": true,
  "message": "Command executed successfully",
  "data": {
    "status": "pending",
    "poll_interval": 1,
    "op_id": "2d37652f2c594d14b927b13756ec9814",
    "success": true,
    "message": "Compilation requested",
    "data": {
      "type": "Compilation",
      "progress": 0,
      "createdAt": "2026-01-06T09:46:42.7193807Z"
    },
    "state_delta": {
      "operations": {
        "pending": [
          {
            "id": "2d37652f2c594d14b927b13756ec9814",
            "type": "Compilation",
            "progress": 0,
            "message": "Compilation requested"
          }
        ]
      }
    },
    "pipeline_kind": "compile",
    "requires_console_validation": true
  }
}
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Good, now let me wait for the compilation to complete.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_unityMCP_unity_editor">
<details>
          <summary>Tool use: **mcp_unityMCP_unity_editor**</summary>
      
*Called tool*: unityMCP - unity_editor: Controls Unity Editor state (play/pause/stop), retrieves project information and full UnityCurrentState, manages editor tools, windows, selection, tags, and layers. Use get_current_state for comprehensive state snapshot.

*Parameters*:
  * action: wait_for_compile
  * op_id: 2d37652f2c594d14b927b13756ec9814
  * timeoutSeconds: 60

*Result*:
{
  "success": true,
  "message": "Command executed successfully",
  "data": {
    "success": false,
    "code": "Operation 2d37652f2c594d14b927b13756ec9814 not found. It may have expired or never existed.",
    "error": "Operation 2d37652f2c594d14b927b13756ec9814 not found. It may have expired or never existed."
  }
}
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
The operation may have completed too quickly. Let me check the console for any errors.</details></think>

---

<tool-use data-tool-type="mcp" data-tool-name="mcp_unityMCP_unity_console">
<details>
          <summary>Tool use: **mcp_unityMCP_unity_console**</summary>
      
*Called tool*: unityMCP - unity_console: Gets messages from or clears the Unity Editor console. Supports filtering by message type, text content, timestamp, and formatting options. Clear action returns a sinceToken for subsequent incremental reads.

*Parameters*:
  * action: get
  * since_token: 639032895986938351-9
  * types: error,exception

*Result*:
{
  "success": true,
  "message": "Command executed successfully",
  "data": {
    "success": true,
    "message": "Retrieved 0 new log entries since token.",
    "data": {
      "entries": [],
      "sinceToken": "639032895986938351-9",
      "tokenValidated": true,
      "providedToken": "639032895986938351-9",
      "startIndex": 0,
      "summary": {
        "total": 0,
        "filtered": false,
        "newSinceToken": true
      }
    }
  }
}
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
No errors were found. The compilation was successful. Let me verify the editor state.</details></think>

---

编译成功，没有错误。修改已完成。

总结一下我做的修改：

1. **添加了焦点管理变量**：
   - `InputControlName` 常量用于标识输入框控件
   - `shouldFocusInput` 布尔值用于标记需要聚焦

2. **修改了 `DrawInputField()` 方法**：
   - 使用 `GUI.SetNextControlName(InputControlName)` 给 TextArea 设置控件名称
   - 在 Repaint 事件时检查 `shouldFocusInput`，如果为 true 则调用 `EditorGUI.FocusTextInControl()` 聚焦到输入框

3. **修改了 `SendRequestAsync()` 和 `CancelSessionAsync()` 的 finally 块**：
   - 在 `isRunning = false` 的同时设置 `shouldFocusInput = true`

这样，每次 AI 响应结束或用户取消后，输入框都会自动获得焦点，用户可以直接继续输入。

---

